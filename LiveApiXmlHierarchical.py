# -*- coding: utf-8 -*-
import sys, re, os, codecs
import xml.etree.ElementTree as ET

reload (sys)
sys.setdefaultencoding ('utf-8')


src_filename = sys.argv [1]
src_basename = os.path.basename (src_filename)
src_abspath = os.path.abspath (src_filename)
if len (sys.argv) > 2:
    dest_filename = sys.argv [2]
else:
    dest_filename = src_basename
    while os.path.exists (dest_filename):
        dest_filename = dest_filename.replace ('.xml', 'h.xml')
with open (src_filename) as src_file:
    filestring = src_file.read ()

# поместить Doc-элемент внутрь предыдущего элемента
filestring = re.compile('(</[^<>]*>)\n\n<Doc>\t(.*?)</Doc>').sub (r'<Doc>\2</Doc>\1', filestring)

src_doc = ET.fromstring (filestring)
src_elems = []
src_elems += src_doc.findall ('Value')
src_elems += src_doc.findall ('Built-In')
src_elems += src_doc.findall ('Property')
src_elems += src_doc.findall ('Method')
src_elems += src_doc.findall ('Sub-Class')
src_elems += src_doc.findall ('Class')
src_elems += src_doc.findall ('Module')


def get_root (elems):
    for elem in elems:
        if elem.text == 'Live': return elem

def text_without_listener_fix_and_device_first (elem):
    text = elem.text
    if text.endswith ('()'): text = text [:-2]
    if elem.tag == 'Module':
        text = re.compile('([a-zA-Z]+)Device').sub (r'Device!\1 ', text)
    elif elem.tag == 'Method':
        text = re.compile('add_(.*)_listener').sub (r'\1 ', text)
        text = re.compile('remove_(.*)_listener').sub (r'\1 ', text)
        text = re.compile('(.*)_has_listener').sub (r'\1 ', text)
    return text
    
def get_children (parent, elems):
    def is_child (elem):
        return elem.text.startswith (parent.text + '.') and len (elem.text.split ('.')) == len (parent.text.split ('.')) + 1
    elems = [elem for elem in elems if is_child (elem)]
    elems.sort (key=text_without_listener_fix_and_device_first)
    return elems

def get_branches (parent, elems):
    def is_branch (elem):
        return elem.text.startswith (parent.text + '.')
    elems = [elem for elem in elems if is_branch (elem)]
    elems.sort (key=text_without_listener_fix_and_device_first)
    return elems

def split_text_to_elems (text):
    text = re.compile(',([^ ])').sub (r', \1', text) # расставить пробелы после запятых
    text = re.compile('"([^ ].*?[^ ])"').sub (r'“\1”', text) # сделать красивые кавычки
    text = re.compile("([^a-z]|^)'([^ ].*?[^ ])'([^a-z]|$)").sub (r'\1‘\2’\3', text) # сделать красивые кавычки
    text = re.compile("([a-z])'([a-z ])").sub (r'\1’\2', text) # сделать красивые кавычки
    text = text.replace ('&lt;', '<')
    text = text.replace ('&gt;', '>').replace ('->', '→')
    text = text.replace ('...', '…')
    text = text.replace (' -- ', ' — ')
    texts = text.split ('C++ signature :  ')
    if len (texts) == 1: # no C++ signature
        description = ET.fromstring ('<Doc type="Description" />')
        description.text = texts [0]
        return (description,)
    else: # C++ signature exist
        fd = texts[0].split (' : ') # format/description text pair
        format = ET.fromstring ('<Doc type="Format" />')
        cpp_signature = ET.fromstring ('<Doc type="Cpp-Signature" />')
        format.text = fd [0]
        cpp_signature.text = texts [1]
        if len (fd) > 1: # description exist
            description = ET.fromstring ('<Doc type="Description" />')
            description.text = fd [1]
            return (format, cpp_signature, description)
        else:
            return (format, cpp_signature)

def copy_elems (parent, elems, dest):
    """ находит всех потомков родителя и для каждого из них вызывает эту же функцию """
    children = get_children (parent, elems)
    for child in children:
        dest_child = ET.Element (child.tag)
        dest_child.set ('name', child.text.split('.') [-1])
        doc = child.find ('Doc')
        if doc is not None:
            for elem in split_text_to_elems (doc.text):
                dest_child.append (elem)
        dest.append (dest_child)
        copy_elems (child, get_branches (child, elems), dest_child)


live_api_elem = ET.Element ('LiveAPI')
version = re.compile('(.*?)(\d(\.\d)*)').sub (r'\2', src_doc.find('.').text.strip ())
live_api_elem.set ('version', version)

# добавить верхнее описание
doc = ET.fromstring ('<Doc type="Description" />')
doc.text = u'Unofficial Live API documentation generated by the “API_MakeDoc” MIDI Remote Script.'
live_api_elem.append (doc)
doc = ET.fromstring ('<Doc type="Description" />')
doc.text = 'This is unofficial documentation. Please do not contact Ableton with questions or problems relating to the use of this documentation.'
live_api_elem.append (doc)

live_elem = ET.fromstring ('<Module name="Live" />')
root = get_root (src_elems)
copy_elems (root, src_elems, live_elem)
live_api_elem.append (live_elem)

dest_doc = ET.ElementTree (live_api_elem)


with open (dest_filename, 'w') as dest_file:
    dest_file.write (codecs.BOM_UTF8)
    dest_file.write ('<?xml version="1.0" encoding="utf-8"?>')
    dest_file.write ('<?xml-stylesheet type="text/xsl" href="LiveAPI.xsl"?>')
    dest_doc.write (dest_file, 'utf-8')
